## Мінуси:
- захардкоджений конфіг
- завантажений файл попередньо зберігається у файл. Таким чином ми обмежуємо себе кількістю місця на диску і швидкістю зчитування з нього
- назва файлу - дата завантаження з точністю в секунду. Якщо два файла будуть завантажені протягом секунди - можливі неприємні колізії
- гарна спроба використати функцію UnmarshalToChan яка парсить файл построчно і маршалить данні у структуру,
  але в подальшому данні з каналу просто додаються у слайс, що нівелює бенефіти цієї функції. Тобто ні виграшу в швидкості за рахунок конкурентності,
  ні оптимізації по памʼяті. Простіше було б заюзати gocsv.Unmarshal(file, transactions) з тим же результатом
- використання log.Fatal() pkg/handler/handler.go:208 Чому б просто не залогувати посилку і закрити канал?
- пропущені return після запису неуспішного статус коду при обробці помиолок pkg/handler/handler.go:64 або тут pkg/repository/transaction_postgres.go:44
- ідея обробляти не унікальні transaction_id має сенс, але реалізувати на рівні аплікейшену погана ідея, достатньо зробити унікальний індекс в бд.
- файл створюється і повернені данні ігноруються, наступною строкою цей же файл відкривається. pkg/handler/handler.go:174 навіщо?
- навіщо структура TransactionService якщо вся логіка в структурі збереження данних в бд? pkg/service/transaction.go:8
- бізнес логіка в сутності що відповідальна за збереження данних